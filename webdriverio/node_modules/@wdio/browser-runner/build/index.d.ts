import LocalRunner from '@wdio/local-runner';
import type { RunArgs, WorkerInstance } from '@wdio/local-runner';
import type { Options } from '@wdio/types';
import type { MaybeMocked, MaybeMockedDeep, MaybePartiallyMocked, MaybePartiallyMockedDeep } from '@vitest/spy';
import type { BrowserRunnerOptions as BrowserRunnerOptionsImport, MockFactoryWithHelper } from './types.js';
export default class BrowserRunner extends LocalRunner {
    #private;
    private options;
    protected _config: Options.Testrunner;
    private _coverageMaps;
    constructor(options: BrowserRunnerOptionsImport, _config: Options.Testrunner);
    /**
     * nothing to initialise when running locally
     */
    initialise(): Promise<void>;
    run(runArgs: RunArgs): Promise<WorkerInstance>;
    /**
     * shutdown vite server
     *
     * @return {Promise}  resolves when vite server has been shutdown
     */
    shutdown(): Promise<boolean>;
    private _generateCoverageReports;
}
declare global {
    namespace WebdriverIO {
        interface BrowserRunnerOptions extends BrowserRunnerOptionsImport {
        }
    }
}
/**
 * re-export mock types
 */
export * from '@vitest/spy';
/**
 * The following exports are meaningless and only there to allow proper type support.
 * The actual implementation can be found in /src/browser.spy.ts
 */
/**
 * Makes all imports to passed module to be mocked.
 *
 * If there is a factory, will return it's result. The call to `mock` is hoisted to the top of the file,
 * so you don't have access to variables declared in the global file scope, if you didn't put them before imports!
 *
 * If __mocks__ folder with file of the same name exist, all imports will return it.
 *
 * If there is no __mocks__ folder or a file with the same name inside, will call original module and mock it.
 *
 * @param {string} path Path to the module.
 * @param {MockFactoryWithHelper} factory (optional) Factory for the mocked module. Has the highest priority.
 */
export declare function mock(path: string, factory?: MockFactoryWithHelper): void;
/**
 * Removes module from mocked registry. All subsequent calls to import will return original module even if it was mocked.
 *
 * @param path Path to the module.
 */
export declare function unmock(moduleName: string): void;
/**
 * Type helpers for TypeScript. In reality just returns the object that was passed.
 * @example
 * import example from './example'
 * vi.mock('./example')
 *
 * test('1+1 equals 2' async () => {
 *  vi.mocked(example.calc).mockRestore()
 *
 *  const res = example.calc(1, '+', 1)
 *
 *  expect(res).toBe(2)
 * })
 *
 * @param item Anything that can be mocked
 * @returns
 */
export declare function mocked<T>(item: T, deep?: true): MaybeMockedDeep<T>;
export declare function mocked<T>(item: T, deep?: false): MaybeMockedDeep<T>;
export declare function mocked<T>(item: T, options: {
    partial?: false;
    deep?: false;
}): MaybeMocked<T>;
export declare function mocked<T>(item: T, options: {
    partial?: false;
    deep: true;
}): MaybeMockedDeep<T>;
export declare function mocked<T>(item: T, options: {
    partial: true;
    deep?: false;
}): MaybePartiallyMocked<T>;
export declare function mocked<T>(item: T, options: {
    partial: true;
    deep: true;
}): MaybePartiallyMockedDeep<T>;
//# sourceMappingURL=index.d.ts.map